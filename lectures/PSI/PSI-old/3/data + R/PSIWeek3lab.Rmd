---
title: "PSI Week3 Lab"
author: "HTML"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
#Exercises 1 to 5
```{r}

#Inspecting the data
#Remember to install these packages if you haven't already done so
library(foreign)
library(pastecs) #For creating descriptive statistic summaries
library(ggplot2) #For creating histograms with more detail than plot
library(psych) # Some useful descriptive functions
library(semTools) #For skewness and kurtosis
library(car) # For Levene's test for homogeneity of variance



#Read in the file
regression <- read.spss("Regression.sav", use.value.labels=TRUE, max.value.labels=Inf, to.data.frame=TRUE)

#Setting the column names to be that used in the dataset
colnames(regression) <- tolower(colnames(regression))

#numerical summary and histograms of variables of interest
#Starting with normexam
#stat.desc is a function form pastecs - make sure you include the basic switch=F and the format to ensure you don't get scienfitic notation
format(stat.desc(regression$normexam), scientific=FALSE)



#skewness and kurtosis from semTools with standard error 
skew<-semTools::skew(regression$normexam)
kurt<-semTools::kurtosis(regression$normexam)
#We divide the skew statistic by the standard error to get the standardised score
skew[1]/skew[2]
kurt[1]/kurt[2]
#Both are falling with the 95% CI

#We will allocate the histogram to a variable to allow use to manipulate it
gg <- ggplot(regression, aes(x=regression$normexam))
#Change the label of the x axis
gg <- gg + labs(x="Normalised Exam Score Age 16")
#manage binwidth and colours
gg <- gg + geom_histogram(binwidth=2, colour="black", aes(y=..density.., fill=..count..))
gg <- gg + scale_fill_gradient("Count", low="#DCDCDC", high="#7C7C7C")


#adding a normal curve
#use stat_function to compute a normalised score for each value of normexam
#pass the mean and standard deviation
#use the na.rm parameter to say how missing values are handled
gg <- gg + stat_function(fun=dnorm, color="red",args=list(mean=mean(regression$normexam, na.rm=TRUE), sd=sd(regression$normexam, na.rm=TRUE)))
#to display the graph request the contents of the variable be shown
gg


#Create a qqplot
qqnorm(regression$normexam)
qqline(regression$normexam, col=2) #show a line on theplot


#Now for Standlrt
#stat.desc is a function form pastecs - make sure you include the basic switch=F to ensure you don't get scienfitic notation

format(stat.desc(regression$standlrt, basic=F), scientific=FALSE)

#skewness and kurtosis from semTools with standard error 

skew<-semTools::skew(regression$standlrt) 
#skewness is an issue 
kurt<-semTools::kurtosis(regression$standlrt)
#We divide the skew statistic by the standard error to get the standardised score
skew[1]/skew[2]
kurt[1]/kurt[2]
#Skewness is an issue so we need to look at the scores (these are already standardised)

#Using +/- 3.29 as our bounds we can treat our data as normal

#We will allocate the histogram to a variable to allow use to manipulate it
gg <- ggplot(regression, aes(x=regression$standlrt))
#Change the label of the x axis
gg <- gg + labs(x="Score on Standard Reading Test Age 11") 
#manage binwidth and colours
gg <- gg + geom_histogram(binwidth=2, colour="black", aes(y=..density.., fill=..count..))
gg <- gg + scale_fill_gradient("Count", low="#DCDCDC", high="#7C7C7C")



#adding a normal curve
#use stat_function to compute a normalised score for each value of standlrt
#pass the mean and standard deviation
#use the na.rm parameter to say how missing values are handled
gg <- gg + stat_function(fun=dnorm, color="red",args=list(mean=mean(regression$standlrt, na.rm=TRUE), sd=sd(regression$standlrt, na.rm=TRUE)))
#to display the graph request the contents of the variable be shown
gg
#Create a qqplot
qqnorm(regression$standlrt)
qqline(regression$standlrt, col=2) #show a line on theplot

```
###Pearson Correlation
```{r}
cor.test(regression$normexam, regression$standlrt, method='pearson')
```
Our correlation level is strong positive and statistically significant


```
#Exercise 6 to (only for selected variables)
```{r}
#We are using a .dat file (survey.dat) created from the SPSS file survey.sav  taken from SPSS Survival Manual 6th Edition Julie Pallant
#http://spss.allenandunwin.com.s3-website-ap-southeast-2.amazonaws.com/data-files.html#.Wb0vvnWP-po
#Results on a survey on well being
#We need to load the file so that we can use it in R.
survey <- read.table("survey.dat")
#Setting the column names to be that used in the dataset
colnames(survey) <- tolower(colnames(survey))

#Descriptive Statistics for Postive Affect, Negative Affect, Self-Esteem, Life Satisfaction
format(stat.desc(survey$tposaff), scientific=FALSE)
#skewness and kurtosis from semTools with standard error 
skew<-skew(survey$tposaff) 
#There is an issue with skewness
kurt<-kurtosis(survey$tposaff)
skew[1]/skew[2]
kurt[1]/kurt[2]

#Create standardised scores, enought are falling within 95 CI to treat as normal
sort(scale(survey$tposaff))
format(stat.desc(survey$tnegaff), scientific=FALSE)
skew<-semTools::skew(survey$tnegaff) 
#There is an issue with skewness
kurt<-semTools::kurtosis(survey$tnegaff)
skew[1]/skew[2]
kurt[1]/kurt[2]
#Create standardised scores, enought are falling within 95 CI to treat as normal
sort(scale(survey$tnegaff))
format(stat.desc(survey$tslfest), scientific=FALSE)
skew<-skew(survey$tslfest) 
#There is an issue with skewness
kurt<-kurtosis(survey$tslfest)
skew[1]/skew[2]
kurt[1]/kurt[2]
#Create standardised scores, enought are falling within 95 CI to treat as normal
sort(scale(survey$tslfest))
format(stat.desc(survey$tlifesat), scientific=FALSE)
skew<-semTools::skew(survey$tlifesat) 
kurt<-semTools::kurtosis(survey$tlifesat)
#Both Skew and Kurtosis are fine
skew[1]/skew[2]
kurt[1]/kurt[2]


#Histograms of postive affect  process is similar for all
gg <- ggplot(survey, aes(x=survey$tposaff))
#Change the label of the x axis
gg <- gg + labs(x="Positive Affect")
#manage binwidth and colours
gg <- gg + geom_histogram(binwidth=2, colour="black", aes(y=..density.., fill=..count..))
gg <- gg + scale_fill_gradient("Count", low="#DCDCDC", high="#7C7C7C")


#adding a normal curve
#use stat_function to compute a normalised score for each value of normexam
#pass the mean and standard deviation
#use the na.rm parameter to say how missing values are handled
gg <- gg + stat_function(fun=dnorm, color="red",args=list(mean=mean(survey$tposaff, na.rm=TRUE), sd=sd(survey$tposaff, na.rm=TRUE)))
#to display the graph request the contents of the variable be shown
gg
#Create a qqplot
qqnorm(survey$tposaff)
qqline(survey$tposaff, col=2) #show a line on theplot


```

###Correlations
```{r}
#Perceived stress and self-esteem; Perceived stress and positive affect; Positive affect and Life Satisfaction
#Simple scatter
scatter <- ggplot(survey, aes(survey$tposaff, survey$tslfest))
#Add a regression line
scatter <- scatter + geom_point() + geom_smooth(method = "lm", colour = "Red", se = F) + labs(x = "Positive Affect", y = "Total Self-Esteem") 
scatter

cor.test(survey$tposaff, survey$tslfest, method='pearson')

#Simple scatter
scatter <- ggplot(survey, aes(survey$tposaff, survey$tpstress))
#Add a regression line
scatter <- scatter + geom_point() + geom_smooth(method = "lm", colour = "Red", se = F) + labs(x = "Positive Affect", y = "Total Perceived Stress")
scatter

cor.test(survey$tposaff, survey$tpstress, method='pearson')

#Simple scatter
scatter <- ggplot(survey, aes(survey$tposaff, survey$tlifesat))
#Add a regression line
scatter <- scatter + geom_point() + geom_smooth(method = "lm", colour = "Red", se = F) + labs(x = "Positive Affect", y = "Life Satisfaction")
scatter
cor.test(survey$tposaff, survey$tlifesat, method='pearson')

```
Our correlation level is strong positive and statistically significant

